# Generate Parentheses

**难度**: `Medium`


## 问题描述

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号
组合。

例如，给出 n = 3，生成结果为：

    [
      "((()))",
      "(()())",
      "(())()",
      "()(())",
      "()()()"
    ]


## 解决方案

### 方案1：直观解法

使用栈存放当前括号，每次入栈一个正括号或者反括号，直至可入栈的括号为0，判断当前栈
内的括号是否有效，如果有效，则加入结果集合。

```python
class Solution:

    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if not s:
            return True

        # 依次存放左括号和与之对应的右括号
        left_parentheses = ['(', '{', '[']
        right_parentheses = [')', '}', ']']
        # 使用列表作为栈
        stack = []
        for i in s:
            if i in left_parentheses:
                # 左括号入栈
                stack.append(i)
            else:
                # 右括号
                if stack:
                    # 如果栈不为空，出栈并判断左右括号是否匹配
                    left = stack.pop()
                    if left != left_parentheses[right_parentheses.index(i)]:
                        return False
                else:
                    # 如果栈为空，说明当前右括号没有与之对应的左括号
                    return False
        return not stack

    def generate(self, result, stack, leftN, rightN):
        """
        :type result: set
        :type stack: list
        :type leftN: int
        :type rightN: int
        :rtype: None
        """
        if leftN == 0 and rightN == 0:
            if self.isValid(stack):
                result.add(''.join(stack))
            return

        if leftN:
            stack.append('(')
            self.generate(result, stack, leftN - 1, rightN)
            stack.pop()
        if rightN:
            stack.append(')')
            self.generate(result, stack, leftN, rightN - 1)
            stack.pop()

    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        if n is None or n <= 0:
            return []
        elif n == 1:
            return ['()']

        res = set()
        stack = []
        stack.append('(')
        self.generate(res, stack, n - 1, n)
        stack.pop()

        stack.append(')')
        self.generate(res, stack, n, n - 1)
        stack.pop()
        return list(res)
```

